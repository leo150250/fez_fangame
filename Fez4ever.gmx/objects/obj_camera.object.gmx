<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>2</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Código para ser executado na câmera (DO JOGO!), logo após o início.
//Esse objeto tem código pra caramba, vai levar séculos para comentar...

//Inicia o módulo 3D e desativa quaisquer vesquícios de iluminação.
d3d_start();
d3d_set_lighting(false);
draw_set_alpha_test(true);

//A variável direção é a variável absoluta da direção que o obj_camera está.
//(0 = direita da room; 90 = topo da room; 180 = esquerda da room; 270 = base da room)
//Ela não tem suavização, pois quem faz a suavização é a variável direcao_view. É a partir dela que acontece o efeitinho legal de tudo girar.
direcao=0;
direcao_view=direcao;

//distorcao = variável de debug. É ela que deixa a câmera um pouco pra cima ou um pouco pra baixo na visualização em perspectiva.
distorcao=0;

//visao = ângulo de abertura da câmera. Está em um valor minúsculo pois a câmera está MUITO afastada dos objetos, precisando de um zoom absurdo.
//Jogos FPS normais tendem a ter esse valor entre 60 e 85.
visao=0.001;
visao_target=0.001;

//distancia = distância da câmera de seu foco. Está em um valor extremamente alto para pode realizar o efeito da projeção ortogonal.
//Jogos TPS (Third-person Shooter) costumam ter esse valor entre 96 e 256.
distancia=10000000;
distancia_target=10000000;

agua=0;
alarm[0]=30;

alpha_fade=1;
target_fade=0;
alpha_hud=1;
target_hud=1;
alarm[1]=150;

//Funções para definir o jogo em tela-cheia.
//Descomente-as somente SE QUISER DEIXAR O JOGO EM TELA-CHEIA. Durante o desenvolvimento, prefiro ele em janela mesmo.

scr_resolucao(false);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>target_hud=0;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (agua==0) {
    agua=1;
} else {
    agua=0;
}
alarm[0]=30;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Código a ser executado a cada frame:

/*É necessário estabelecer um limite entre 0 e 359.99999999999999999999999999999999999999999999999999(INF),
pois as variáveis de sistema relacionadas a direção em graus radianos não passam disso. Então, para fins de compatibilidade,
foi inserido um limite.
É claro que, no caso da direcao_view, ela vai obter números negativos SIM, principalmente quando alterar a direção de 270 para 0,
mas isso é para que se faça a compatibilidade do negócio, senão a câmera iria do 270 para o 0 passando pelo 180 e pelo 90, o que não seria legal de ver.*/

//Se a variável direcao ficar menor que 0, então aumenta-se 360 nos cálculos das variáveis direcao e direcao_view.
if (direcao&lt;0) {
    direcao+=360;
    direcao_view+=360;
}
//Se a variável direcao ficar maior ou igual que 360, então diminui-se 360 nos cálculos das variáveis direcao e direcao_view.
if (direcao&gt;=360) {
    direcao-=360;
    direcao_view-=360;
}

//As funções abaixo são para causar o efeito de suavização na direcao_view.
//Isto é, apenas pega o valor da diferença entre a direcao e a direcao_view e divide por 5. No próximo frame, faz de novo, e no próximo, e no próximo...
if (direcao_view&lt;direcao) {
    direcao_view+=(direcao-direcao_view)/5;
} else if (direcao_view&gt;direcao) {
    direcao_view-=(direcao_view-direcao)/5;
}
//...até que a diferença entre as variáveis seja menor que 0.1... Nesse caso, aí a variável é arredondada, para poder tratá-la melhor, sem "quebrados"!
if (direcao-direcao_view&lt;0.1) and (direcao_view-direcao&lt;0.1) {
    direcao_view=round(direcao_view);
}

if (distancia&gt;distancia_target) { distancia-=(distancia-distancia_target)/10 }
if (distancia&lt;distancia_target) { distancia+=(distancia_target-distancia)/10 }
if (visao&gt;visao_target) { visao-=(visao-visao_target)/10 }
if (visao&lt;visao_target) { visao+=(visao_target-visao)/10 }

if (alpha_fade&gt;target_fade) { alpha_fade-=0.02; }
if (alpha_fade&lt;target_fade) { alpha_fade+=0.02; }
if (alpha_hud&gt;target_hud) { alpha_hud-=0.01; }
if (alpha_hud&lt;target_hud) { alpha_hud+=0.01; }
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="5" enumb="87">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Códigos para quando a tecla W está sendo pressionada:

//ISSO É DEBUG! DEBUUUG! TEM QUE TIRAR ISSO NO PRODUTO FINAL!
//Apenas define a distorção da câmera para 32, deixando a visão de cima pra baixo, como nos TPS's.
//Funciona só na projeção de perspectiva.
distorcao=32;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="5" enumb="83">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Códigos para quando a tecla S está sendo pressionada:

//ISSO É DEBUG! DEBUUUG! TEM QUE TIRAR ISSO NO PRODUTO FINAL!
//Apenas define a distorção da câmera para -32, deixando a visão de baixo pra cima.
//Funciona só na projeção de perspectiva.
distorcao=-32;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="64">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Código para o desenho do HUD do jogo

draw_set_alpha(alpha_fade);
draw_set_color(c_black);
draw_rectangle(0,0,display_get_gui_width(),display_get_gui_height(),false);
draw_set_alpha(alpha_hud);
draw_set_color(c_white);
draw_sprite(spr_hud_cubebit,obj_gomez.cubebit,32,32);
draw_sprite(spr_hud_cubeshard,0,32,96);
draw_sprite(spr_hud_key,0,32,160);
draw_sprite(spr_hud_anticube,0,32,224);
draw_set_color(c_black);
draw_set_halign(fa_left);
draw_set_valign(fa_middle);
draw_text(64,32,string(obj_gomez.cubebit));
draw_text(64,96,string(obj_gomez.cubeshard));
draw_text(64,160,0);
draw_text(64,224,string(obj_gomez.anticube));

//Esses códigos aqui embaixo são só pra exibir algumas variáveis na tela.
//Tenho que tirar isso mais tarde.
//DEBUG!
//draw_set_alpha(1);
//draw_sprite(spr_cubebit,0,display_get_gui_width()/2,display_get_gui_height()/2);
/*
draw_set_color(c_black);
draw_set_halign(fa_left);
draw_set_valign(fa_top);
draw_text(0,0,"fps: "+string(fps)+"
fps_real: "+string(fps_real)+"
obj_camera.direcao: "+string(direcao)+"
obj_camera.direcao_view: "+string(direcao_view)+"
obj_gomez.atual_z: "+string(obj_gomez.atual_z)+"
obj_gomez.bloqueio: "+string(obj_gomez.bloqueio)+"
instance_number(obj_block): "+string(instance_number(obj_block))
);
*/
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Código para o evento de desenha da câmera

//É aqui que a mágica acontece.
//Primeiro, setamos para que a camada alpha da projeção seja 1, pra não ficar nada transparente...
draw_set_alpha(1);
//Depois, setamos a coloração da projeção para c_white, para que nada sofra nenhuma alteração de cores...
draw_set_color(c_white);
//Em seguida, fazemos o fundo da fase com desenhos de retângulos coloridos em 2D:
draw_rectangle_color(0,0,view_wview[0],view_hview[0],c_aqua,c_aqua,c_aqua,c_aqua,false);
//Extremo céu
//draw_rectangle_color(0,-(obj_camera_look.z/5)+480,view_wview[0],480,c_aqua,c_aqua,c_blue,c_blue,false);
//Céu mediano
//draw_rectangle_color(0,-(obj_camera_look.z/5),view_wview[0],-(obj_camera_look.z/5)+480,c_white,c_white,c_aqua,c_aqua,false);
//Céu de baixo
//draw_rectangle_color(0,0,view_wview[0],-(obj_camera_look.z/5),c_white,c_white,c_white,c_white,false);
//Depois, fazemos uma tentativa fracassada de criar um negócio de água:
//draw_rectangle_color(0,0,view_wview[0],(view_hview[0]/2)-(obj_camera_look.z*2),c_blue,c_blue,c_blue,c_blue,false);
//E depois, fazemos a projeção do mundo 3D.
//Essa projeção que é o truque. O lengthdir_x/y faz um cálculo para que a câmera esteja sempre em um círculo em volta do personagem,
//de raio de acordo com a variável distancia, na posição do direcao_view.
//Ainda preciso corrigir a taxa de aspecto do 3D (aquele 640/480 lá no final).
d3d_set_projection_ext(obj_camera_look.x+lengthdir_x(distancia,direcao_view),obj_camera_look.y+lengthdir_y(distancia,direcao_view),obj_camera_look.z+distorcao,obj_camera_look.x,obj_camera_look.y,obj_camera_look.z,0,0,1,visao,window_get_width()/window_get_height(),(distancia/2),(distancia*2));
//E depois, uma tentativa bem-sucedida de fazer o "negócio" de água, que nada mais é do que a água, propriamente dita:
d3d_draw_wall(1280,-512,4,1280,1024,-252,sprite_get_texture(spr_agua,agua),6,1);
d3d_draw_wall(-512,-512,4,1280,-512,-252,sprite_get_texture(spr_agua,agua),7,1);
d3d_draw_wall(-512,-512,4,-512,1024,-252,sprite_get_texture(spr_agua,agua),6,1);
d3d_draw_wall(-512,1024,4,1280,1024,-252,sprite_get_texture(spr_agua,agua),7,1);
d3d_draw_floor(-512,-512,4,1280,1024,4,sprite_get_texture(spr_agua,2),7,6);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="90">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Código para quando apertar a tecla Z

//Eu estava fazendo isso para ver qual é a melhor projeção para a visão ortogonal.
//DEBUG!
visao+=0.001;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="81">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Código para quando apertar a tecla Q

//Eu estava fazendo isso para ver qual é a melhor projeção para a visão ortogonal.
//DEBUG!
distancia+=1000;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="69">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Código para quando apertar a tecla E

//Eu estava fazendo isso para ver qual é a melhor projeção para a visão ortogonal.
//DEBUG!
distancia-=1000;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="68">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Código para quando apertar a tecla D

//Altera a direção da câmera em -90, girando-a no sentido anti-horário, de acordo com a visão do mapa.
if (obj_gomez.pause==false) {
    direcao-=90;
    audio_play_sound(snd_rotate_right,1,false);
    if (direcao==90) or (direcao==-90) {
        obj_gomez.x=obj_gomez.girox;
        obj_camera_look.x=obj_gomez.x;
    }
    if (direcao==180) or (direcao==0) {
        obj_gomez.y=obj_gomez.giroy;
        obj_camera_look.y=obj_gomez.y;
    }
    //E define para que, se o Gomez se mover nessa nova câmera, deve-se atualizar a profundidade.
    obj_gomez.pause=true;
    obj_gomez.alarm[0]=20;
    obj_gomez.atualizar_profundidade=true;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="67">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Código para quando apertar a tecla C

//Eu estava fazendo isso para ver qual é a melhor projeção para a visão ortogonal.
//DEBUG!
visao-=0.001;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="65">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Código para quando apertar a tecla A

//Altera a direção da câmera em +90, girando-a no sentido horário, de acordo com a visão do mapa.
if (obj_gomez.pause==false) {
    direcao+=90;
    if (direcao==90) or (direcao==270) {
        obj_gomez.x=obj_gomez.girox;
        obj_camera_look.x=obj_gomez.x;
    }
    if (direcao==180) or (direcao==360) {
        obj_gomez.y=obj_gomez.giroy;
        obj_camera_look.y=obj_gomez.y;
    }
    audio_play_sound(snd_rotate_left,1,false);
    
    //E define para que, se o Gomez se mover nessa nova câmera, deve-se atualizar a profundidade.
    obj_gomez.pause=true;
    obj_gomez.alarm[0]=20;
    obj_gomez.atualizar_profundidade=true;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="27">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Código para o evento de apertar a tecla ESC

//Faz algo muito importante para os jogos atuais: Sai do jogo.
game_end();
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
